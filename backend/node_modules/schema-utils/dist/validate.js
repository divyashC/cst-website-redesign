"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
<<<<<<< HEAD
=======
exports.validate = validate;
>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
Object.defineProperty(exports, "ValidationError", {
  enumerable: true,
  get: function () {
    return _ValidationError.default;
  }
});
<<<<<<< HEAD
exports.validate = validate;
var _absolutePath = _interopRequireDefault(require("./keywords/absolutePath"));
var _ValidationError = _interopRequireDefault(require("./ValidationError"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
=======

var _absolutePath = _interopRequireDefault(require("./keywords/absolutePath"));

var _ValidationError = _interopRequireDefault(require("./ValidationError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
/**
 * @template T
 * @param fn {(function(): any) | undefined}
 * @returns {function(): T}
 */
const memoize = fn => {
  let cache = false;
  /** @type {T} */
<<<<<<< HEAD
=======

>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
  let result;
  return () => {
    if (cache) {
      return result;
    }
<<<<<<< HEAD
    result = /** @type {function(): any} */fn();
    cache = true;
    // Allow to clean up memory for fn
    // and all dependent resources
    // eslint-disable-next-line no-undefined, no-param-reassign
=======

    result =
    /** @type {function(): any} */
    fn();
    cache = true; // Allow to clean up memory for fn
    // and all dependent resources
    // eslint-disable-next-line no-undefined, no-param-reassign

>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
    fn = undefined;
    return result;
  };
};
<<<<<<< HEAD
const getAjv = memoize(() => {
  // Use CommonJS require for ajv libs so TypeScript consumers aren't locked into esModuleInterop (see #110).
  // eslint-disable-next-line global-require
  const Ajv = require("ajv").default;
  // eslint-disable-next-line global-require
  const ajvKeywords = require("ajv-keywords").default;
  // eslint-disable-next-line global-require
  const addFormats = require("ajv-formats").default;

  /**
   * @type {Ajv}
   */
  const ajv = new Ajv({
    strict: false,
=======

const getAjv = memoize(() => {
  // Use CommonJS require for ajv libs so TypeScript consumers aren't locked into esModuleInterop (see #110).
  const Ajv = require("ajv");

  const ajvKeywords = require("ajv-keywords");

  const ajv = new Ajv({
>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
    allErrors: true,
    verbose: true,
    $data: true
  });
<<<<<<< HEAD
  ajvKeywords(ajv, ["instanceof", "patternRequired"]);
  addFormats(ajv, {
    keywords: true
  });
  // Custom keywords
  (0, _absolutePath.default)(ajv);
  return ajv;
});

/** @typedef {import("json-schema").JSONSchema4} JSONSchema4 */
/** @typedef {import("json-schema").JSONSchema6} JSONSchema6 */
/** @typedef {import("json-schema").JSONSchema7} JSONSchema7 */
=======
  ajvKeywords(ajv, ["instanceof", "formatMinimum", "formatMaximum", "patternRequired"]); // Custom keywords

  (0, _absolutePath.default)(ajv);
  return ajv;
});
/** @typedef {import("json-schema").JSONSchema4} JSONSchema4 */

/** @typedef {import("json-schema").JSONSchema6} JSONSchema6 */

/** @typedef {import("json-schema").JSONSchema7} JSONSchema7 */

>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
/** @typedef {import("ajv").ErrorObject} ErrorObject */

/**
 * @typedef {Object} Extend
<<<<<<< HEAD
 * @property {string=} formatMinimum
 * @property {string=} formatMaximum
 * @property {string=} formatExclusiveMinimum
 * @property {string=} formatExclusiveMaximum
=======
 * @property {number=} formatMinimum
 * @property {number=} formatMaximum
 * @property {boolean=} formatExclusiveMinimum
 * @property {boolean=} formatExclusiveMaximum
>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
 * @property {string=} link
 */

/** @typedef {(JSONSchema4 | JSONSchema6 | JSONSchema7) & Extend} Schema */

/** @typedef {ErrorObject & { children?: Array<ErrorObject>}} SchemaUtilErrorObject */

/**
 * @callback PostFormatter
 * @param {string} formattedError
 * @param {SchemaUtilErrorObject} error
 * @returns {string}
 */

/**
 * @typedef {Object} ValidationErrorConfiguration
 * @property {string=} name
 * @property {string=} baseDataPath
 * @property {PostFormatter=} postFormatter
 */

/**
 * @param {Schema} schema
 * @param {Array<object> | object} options
 * @param {ValidationErrorConfiguration=} configuration
 * @returns {void}
 */
<<<<<<< HEAD
function validate(schema, options, configuration) {
  let errors = [];
=======

function validate(schema, options, configuration) {
  let errors = [];

>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
  if (Array.isArray(options)) {
    errors = Array.from(options, nestedOptions => validateObject(schema, nestedOptions));
    errors.forEach((list, idx) => {
      const applyPrefix =
      /**
       * @param {SchemaUtilErrorObject} error
       */
      error => {
        // eslint-disable-next-line no-param-reassign
<<<<<<< HEAD
        error.instancePath = `[${idx}]${error.instancePath}`;
=======
        error.dataPath = `[${idx}]${error.dataPath}`;

>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
        if (error.children) {
          error.children.forEach(applyPrefix);
        }
      };
<<<<<<< HEAD
=======

>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
      list.forEach(applyPrefix);
    });
    errors = errors.reduce((arr, items) => {
      arr.push(...items);
      return arr;
    }, []);
  } else {
    errors = validateObject(schema, options);
  }
<<<<<<< HEAD
=======

>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
  if (errors.length > 0) {
    throw new _ValidationError.default(errors, schema, configuration);
  }
}
<<<<<<< HEAD

=======
>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
/**
 * @param {Schema} schema
 * @param {Array<object> | object} options
 * @returns {Array<SchemaUtilErrorObject>}
 */
<<<<<<< HEAD
=======


>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
function validateObject(schema, options) {
  const compiledSchema = getAjv().compile(schema);
  const valid = compiledSchema(options);
  if (valid) return [];
  return compiledSchema.errors ? filterErrors(compiledSchema.errors) : [];
}
<<<<<<< HEAD

=======
>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
/**
 * @param {Array<ErrorObject>} errors
 * @returns {Array<SchemaUtilErrorObject>}
 */
<<<<<<< HEAD
function filterErrors(errors) {
  /** @type {Array<SchemaUtilErrorObject>} */
  let newErrors = [];
  for (const error of /** @type {Array<SchemaUtilErrorObject>} */errors) {
    const {
      instancePath
    } = error;
    /** @type {Array<SchemaUtilErrorObject>} */
    let children = [];
    newErrors = newErrors.filter(oldError => {
      if (oldError.instancePath.includes(instancePath)) {
        if (oldError.children) {
          children = children.concat(oldError.children.slice(0));
        }

        // eslint-disable-next-line no-undefined, no-param-reassign
=======


function filterErrors(errors) {
  /** @type {Array<SchemaUtilErrorObject>} */
  let newErrors = [];

  for (const error of
  /** @type {Array<SchemaUtilErrorObject>} */
  errors) {
    const {
      dataPath
    } = error;
    /** @type {Array<SchemaUtilErrorObject>} */

    let children = [];
    newErrors = newErrors.filter(oldError => {
      if (oldError.dataPath.includes(dataPath)) {
        if (oldError.children) {
          children = children.concat(oldError.children.slice(0));
        } // eslint-disable-next-line no-undefined, no-param-reassign


>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
        oldError.children = undefined;
        children.push(oldError);
        return false;
      }
<<<<<<< HEAD
      return true;
    });
    if (children.length) {
      error.children = children;
    }
    newErrors.push(error);
  }
=======

      return true;
    });

    if (children.length) {
      error.children = children;
    }

    newErrors.push(error);
  }

>>>>>>> 1b8efb50bc7464ce5e6ed9660386268b24ee8cac
  return newErrors;
}